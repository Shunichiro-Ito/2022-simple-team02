// Copyright (C) 2017  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench template that is freely editable to  
// suit user's needs .Comments are provided in each section to help the user    
// fill out necessary details.                                                  
// *****************************************************************************
// Generated on "05/19/2022 16:41:47"
                                                                                
// Verilog Test Bench template for design : processor
// 
// Simulation tool : ModelSim-Altera (Verilog)
// 

`timescale 1 ns/ 1 ps
module processor_vlg_tst();
// constants                                           
// general purpose registers
reg eachvec;
// test vector input registers
reg clock;
reg exec;
reg [15:0] externalInput;
reg reset;
// wires                                               
wire [3:0]  ALUOp_control;
wire [3:0]  ALUOp_EX;
wire [15:0]  ALUResult;
wire ALUSrcAR_control;
wire ALUSrcAR_EX;
wire [15:0]  AR_data;
wire [15:0]  AR_forwarded;
wire [15:0]  BR_data;
wire [15:0]  BR_forwarded;
wire branch_control_ID;
wire branch_hazDU;
wire [15:0]  d_data_EX;
wire [15:0]  DR_data_addressMem;
wire DRSrc_control;
wire DRSrc_EX;
wire EX_memRead_;
wire EX_memRead_hazDU;
wire EX_regWrite_;
wire EX_RegWrite_fwdU;
wire [2:0]  EXMEM_RegRd_fwdU;
wire [15:0]  externalOutput;
wire fwdA0;
wire fwdA1;
wire [1:0]  FwdA_fwdU;
wire fwdB0;
wire fwdB1;
wire [1:0]  FwdB_fwdU;
wire [2:0]  IDEX_RegRd_fwdU;
wire [2:0]  IDEX_RegRd_hazDU;
wire IDFlush_hazDU;
wire IFFlush_control;
wire IFFlush_hazDU;
wire [2:0]  IFID_Rd_hazDU;
wire [2:0]  IFID_Rs_hazDU;
wire [2:0]  IFIDRegRd;
wire IFIDWrite_hazDU;
wire [2:0]  IFIF_RegRd;
wire inputEnable_control;
wire inputEnable_MEM;
wire IR_changeEnable;
wire [15:0]  IR_data;
wire IR_reset;
wire [15:0]  MDR;
wire MEM_regWrite_fwdU;
wire MEM_regWrite_MEM;
wire memRead_control;
wire memRead_MEM;
wire memToReg;
wire memToReg_control;
wire memWrite_control;
wire memWrite_MEM;
wire notReadRsRd_control;
wire notReadRsRd_hazDU;
wire outputEnable_control;
wire outputEnable_EX;
wire PC_changeEnable;
wire [15:0]  PC_data;
wire PCWrite_control;
wire PCWrite_hazDU;
wire [15:0]  RaRsfieldALU;
wire [15:0]  RbRdfieldALU;
wire regDst_control_ID;
wire regWrite_control;
wire regWrite_WB;
wire systemRunning_control;
wire SZCVSrc_control;
wire SZCVSrc_EX;
wire wrenMem;

// assign statements (if any)                          
processor i1 (
// port map - connection between master ports and signals/registers   
	.ALUOp_control(ALUOp_control),
	.ALUOp_EX(ALUOp_EX),
	.ALUResult(ALUResult),
	.ALUSrcAR_control(ALUSrcAR_control),
	.ALUSrcAR_EX(ALUSrcAR_EX),
	.AR_data(AR_data),
	.AR_forwarded(AR_forwarded),
	.BR_data(BR_data),
	.BR_forwarded(BR_forwarded),
	.branch_control_ID(branch_control_ID),
	.branch_hazDU(branch_hazDU),
	.clock(clock),
	.d_data_EX(d_data_EX),
	.DR_data_addressMem(DR_data_addressMem),
	.DRSrc_control(DRSrc_control),
	.DRSrc_EX(DRSrc_EX),
	.EX_memRead_(EX_memRead_),
	.EX_memRead_hazDU(EX_memRead_hazDU),
	.EX_regWrite_(EX_regWrite_),
	.EX_RegWrite_fwdU(EX_RegWrite_fwdU),
	.exec(exec),
	.EXMEM_RegRd_fwdU(EXMEM_RegRd_fwdU),
	.externalInput(externalInput),
	.externalOutput(externalOutput),
	.fwdA0(fwdA0),
	.fwdA1(fwdA1),
	.FwdA_fwdU(FwdA_fwdU),
	.fwdB0(fwdB0),
	.fwdB1(fwdB1),
	.FwdB_fwdU(FwdB_fwdU),
	.IDEX_RegRd_fwdU(IDEX_RegRd_fwdU),
	.IDEX_RegRd_hazDU(IDEX_RegRd_hazDU),
	.IDFlush_hazDU(IDFlush_hazDU),
	.IFFlush_control(IFFlush_control),
	.IFFlush_hazDU(IFFlush_hazDU),
	.IFID_Rd_hazDU(IFID_Rd_hazDU),
	.IFID_Rs_hazDU(IFID_Rs_hazDU),
	.IFIDRegRd(IFIDRegRd),
	.IFIDWrite_hazDU(IFIDWrite_hazDU),
	.IFIF_RegRd(IFIF_RegRd),
	.inputEnable_control(inputEnable_control),
	.inputEnable_MEM(inputEnable_MEM),
	.IR_changeEnable(IR_changeEnable),
	.IR_data(IR_data),
	.IR_reset(IR_reset),
	.MDR(MDR),
	.MEM_regWrite_fwdU(MEM_regWrite_fwdU),
	.MEM_regWrite_MEM(MEM_regWrite_MEM),
	.memRead_control(memRead_control),
	.memRead_MEM(memRead_MEM),
	.memToReg(memToReg),
	.memToReg_control(memToReg_control),
	.memWrite_control(memWrite_control),
	.memWrite_MEM(memWrite_MEM),
	.notReadRsRd_control(notReadRsRd_control),
	.notReadRsRd_hazDU(notReadRsRd_hazDU),
	.outputEnable_control(outputEnable_control),
	.outputEnable_EX(outputEnable_EX),
	.PC_changeEnable(PC_changeEnable),
	.PC_data(PC_data),
	.PCWrite_control(PCWrite_control),
	.PCWrite_hazDU(PCWrite_hazDU),
	.RaRsfieldALU(RaRsfieldALU),
	.RbRdfieldALU(RbRdfieldALU),
	.regDst_control_ID(regDst_control_ID),
	.regWrite_control(regWrite_control),
	.regWrite_WB(regWrite_WB),
	.reset(reset),
	.systemRunning_control(systemRunning_control),
	.SZCVSrc_control(SZCVSrc_control),
	.SZCVSrc_EX(SZCVSrc_EX),
	.wrenMem(wrenMem)
);
initial                                                
begin                                                  
// code that executes only once                        
// insert code here --> begin                          
clock <= 0;
reset <= 0;
exec  <= 1;
externalInput <= 16'hffef;                                                       
// --> end                                             
$display("Running testbench");                       
end                                                    
always                                                 
// optional sensitivity list                           
// @(event1 or event2 or .... eventn)                  
begin                                                  
// code executes for every event on sensitivity list   
// insert code here --> begin                          
#1010
reset <= 1;
#1000
exec <= 0;
#1600  
exec <= 1;
#11000
exec <= 0;
#2000
exec <= 1;                                                     
@eachvec;                                              
// --> end                                             
end
always begin
#50
clock <= ~clock;
end

endmodule

