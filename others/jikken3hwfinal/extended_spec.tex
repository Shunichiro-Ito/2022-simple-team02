\documentclass[a4j,titlepage]{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}
\usepackage{float}
\usepackage{amssymb}%にやりイコールを使う
\usepackage{multirow}
\usepackage{multicol}
%\usepackage{color}

\begin{document}

\title{2022 年度 3 回生前期学生実験 HW  \\ \bf team02 アーキテクチャ拡張仕様書}
% ↓ここに自分の氏名を記入
\author{アーキテクチャ拡張仕様書:植田健斗\\
グループメンバー：\\伊藤舜一郎 (学籍番号:1029-32-7548)
\\植田健斗　(学籍番号:1029-32-6498)}
\西暦
\date{提出期限：6月9日13時　提出日: \today} % コンパイル時の日付が自動で挿入される
\maketitle
\newpage

\section{SIMPLE/B基本アーキテクチャからの拡張仕様の説明}
SIMPLE/B基本アーキテクチャをもとにして、拡張機能の追加をしたプロセッサを設計した。
以下の機能を追加した。
\begin{itemize}
\item 5段のパイプライン処理
\item 即値命令ADDIの実装
\end{itemize}

\section{拡張を行うことによる利益}

拡張を行うことで、プロセッサの実行時間が短くなった。
以下それぞれの拡張により向上した性能を説明する。

\section{5段のパイプライン処理}
\subsection{概要}
処理をIF,ID,EX,MEM,WBの5つのフェーズに分けてそれらを並列に処理を行う。
その実装に伴いフォーワーディングユニット、ハザード検出ユニット、パイプラインレジスタを追加し、
制御部を一部変更した。

データハザードに対処するためにフォーワーディングを実装した。
さらに、LD,IN命令のMEMフェーズの終わりにわかるデータを次の命令のEXフェーズで使う状況で起こる、フォーワーディングで
対処できないデータハザード(パイプラインハザード)に
は対処してある。具体的にはLD,IN命令で読み込むデータを次の命令で参照する際にLD,IN命令の次にNOP命令を挟むことで、
対処している。

また、分岐の際の制御ハザードに対処している。次のようにして制御ハザードに対処している。
分岐が不成立であると予測して命令を読み込む。
分岐が不成立の場合、そのまま処理を続ける。
成立した場合、不成立と予測して読み込んだ命令が1つあるので、それをNOP命令に置き換えて、分岐先の新しい番地の命令を読み込む。

\subsection{性能の評価}
中間報告時の拡張前のマルチサイクル方式でのSIMPLE/BではCPIは5であったが、
最終報告時のパイプライン方式でのSIMPLE/BではCPIは以下のようになる。ただしCPIが以下のようになるまでに4サイクルかかる。
\begin{itemize}
    \item ロード命令(LD)は1だが、ロード命令で書きこむレジスタの内容を次の命令で読み出す場合は2
    \item 入力命令(IN)は1以上で、execボタンが押されるまでのクロック数。
    \item 条件分岐・無条件分岐命令はいずれも、分岐が不成立の場合は1、成立する場合は2
    \item その他の命令は、すべて1
\end{itemize}
これにより、このプロセッサの平均的なCPIは命令数が多い場合は1以上2以下の値となる。以下のことを行うことでCPIを1に限りなく近くすることができる。
\begin{itemize}
    \item ロード命令(LD)の次の命令で、LD命令で読み込むデータを参照しない。
    \item ループ展開などにより、条件分岐命令を減らす。
    \item 命令数を多くする。
\end{itemize}

また、中間報告時のマルチサイクル方式のSIMPLE/BではTotal logic elementが2129であり、
最終報告のパイプライン方式の拡張後のSIMPLE/BではTotal logic elementが2556である。
パイプライン方式になりTotal logic elementは427増えた。もともとのマルチサイクル方式のおよそ1.2倍の回路規模に
なっている。


\section{即値加算命令ADDI命令の実装}
\subsection{概要}
命令の上位5bitが二進数で10001のときにこの命令が呼ばれる。
Rbフィールド(命令の10から8bit目)で指定した番号のレジスタの中身を読み出し、命令の下8bitで指定した符号付きの値dを足し合わせる。
足し合わせた値をRbフィールドで指定したレジスタに格納する。Rbフィールドの値により、条件コードが
設定される。条件コード C には最上位ビットからの桁上げが設定される。

\subsection{性能の評価}
制御信号を書き換えのみを行い実装したため、追加のコンポーネントはないので拡張命令のコスト遅延はほとんどないと思われる。
ADDI命令の利点としてソートのアルゴリズムを書く際に、  -126以上125以下の定数を加算したいときに、ADDI命令がない場合は
LIとADD命令を組み合わせ2命令かけて実装しなければならないがそれを1命令で実行できることがあげられる。

ADDIがない場合、ループ内でインデックスをインクリメントするときに、LIとADD命令を使い
2命令かけて実行するか、それとも、一命令でやる場合にはレジスタに1を保存しておく必要がある。
ADDIがある場合、レジスタに1を保存せずに1命令で実行することができるので、
レジスタを使わずに実行命令数を増やさないということができる。

実際、度数ソート(dosuSort.mif)のプログラムの一部(36から53行目)を例に挙げて
定量的な評価をおこなう。
以下は0番レジスタの値がループインデックスになっていて、1024回の繰り返す1重のループ命令になっている。
このコードのループを実行されるときには、レジスタは8個すべて使われている。
0から4番レジスタも変数を格納するのに使っていて、
5,6,7番レジスタはそれぞれ定数0x100,0x800,0xffの定数を格納するのに
使っている。
この状況で1024回のループを回すのに、
定数1を保存するためのレジスタを確保できない状況で、0番レジスタの値(idx)を
インクリメントしなければいけない。
\begin{screen}
\begin{verbatim}
    LI 0, 1
    SLL 0, 10
    LI 7, -1
    SRL 7, 8
    LD 3, 0, 0
    MOV 1, 7
    AND 1, 3
    LD 4, 0, 1
    MOV 2, 1
    ADD 2, 5
    LD 2, 0, 2
    ADDI 0, 1
    SUB 2, 4
    ADDI 4, -1
    ST 3, 0, 2
    ST 4, 0, 1
    CMP 0, 6
    BNE -14
\end{verbatim}
\end{screen}
このような状況で、定数1を格納するレジスタは確保することができないので、
ADDI命令がなければ定数レジスタを一つ使い、例えば0x100を格納する5番レジスタを使い
、それをシフトすることで定数1を作らなければならない。以下の変更をすることで
ADDI命令がない場合に同じ処理を実行できる。
\begin{itemize}
    \item ADDI 0, 1がある場所の上に、SRL 5, 8を追加する。
    \item ADDI 0, 1をADD 0, 5に変える。
    \item ADDI 0, -1をSUB 0, 5に変える。
    \item ADD 2, 5命令の上にSLL 5, 8命令を追加する。
    \item BNE -14をBNE -16に変更する。
\end{itemize}
以下がこれらの変更をし、ADDIを用いずに同じ内容を表現したアセンブリコードである。
\begin{screen}
\begin{verbatim}
    LI 0, 1
    SLL 0, 10
    LI 7, -1
    SRL 7, 8
    LD 3, 0, 0
    MOV 1, 7
    AND 1, 3
    LD 4, 0, 1
    MOV 2, 1
    SLL 5, 8
    ADD 2, 5
    LD 2, 0, 2
    SRL 5, 8
    ADD 0, 5
    SUB 2, 4
    SUB 4, 5
    ST 3, 0, 2
    ST 4, 0, 1
    CMP 0, 6
    BNE -16
\end{verbatim}
\end{screen}
ADDIが込みでの命令では、14命令と分岐成立の際に挿入されるNOPで1回のループ当たり、
15クロックかかるので、初めの4命令と合わせて$4+1024*15=15364$クロックサイクルかかる。
ADDIがないと、この例ではループ内の命令数が2つ増える。
このループは1024回繰り返されるので、この例ではADDIがある
場合のほうがない場合より2048クロック多くなり、$15364+2048=17412$クロックサイクルになるということがわかる。

この例ではADDIが実装されたことで
クロックサイクル数は約0.882倍になる。
さらに、50MHzで実行する場合を考えると、
20ns×2048で40μsほど実行時間が短くなる。


\end{document}
